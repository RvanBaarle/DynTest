module main

imports
  signatures/start-sig

signature
  sorts PATH LABEL SCOPE
  constructors
    PathStep : PATH * LABEL * SCOPE -> PATH
    PathEmpty : SCOPE -> PATH
    Label : string -> LABEL
    Scope : string * string -> SCOPE


primitives
  statement #print(@value)
  statement #exit()
  expression #int-add(@value, @value)
  expression #int-sub(@value, @value)
  expression #int-mul(@value, @value)
  expression #int-div(@value, @value)
//  expression #record-new()
//  expression #record-read(@value, @value)
//  expression #record-write(@value, @value, @value)
  expression #ref-new(@value)
  expression #ref-fetch(@value)
  expression #ref-store(@value, @value)
  conditional #int-eq(@value, @value)

constraint-analyzer
  property ref :: 'ID
  property scope :: 'SCOPE
  property vars :: 'ID

signature
constructors
  String : STRING -> Value

rules
  $exit :: @value

  evalProgram :: 'Start -> Holy
  
  evalVars :: List('ID) -> Holy
  
  evalVar :: 'ID -> Holy

  evalStatements :: List('Statement) -> Holy

  evalStatement :: 'Statement -> Holy

  evalExpression :: 'Expression -> Holy(@value)

  evalExpressions :: List('Expression) -> Holy(List(@value))

  makeParamVars :: List('ID) -> List(@value)

  evalParameters :: List('ID) * List(@value) -> Holy

  evalJumpLabels :: List('Statement) -> Holy

  evalCondition :: 'Condition * @value * @value -> @statement

  evalElse :: 'Else * @value -> Holy(@value)
  
  resolveVar :: 'ID -> @value
  
  unpackPath :: List('PATH) -> 'PATH
  
  unpackScope :: List('SCOPE) -> 'string
  
  unpackIdList :: List(List('ID)) -> List('ID)

  evalProgram(p@Program(l)) = {
    with $exit = exit do {
      evalVars(vars(p))
      evalJumpLabels(l)
      evalStatements(l)
      $exit@([])
    }
  }
  label exit/0:
  
  evalVar(x) = {
    v <- resolveVar(x)
    ref <- #ref-new(int('0))
    let v = ref in hole
  }
  
  evalVars([a|b]) = {
    evalVar(a)
    evalVars(b)
  }
  evalVars([]) = hole

  evalJumpLabels([JumpLabel(l)|sts]) = {
    v <- var(l)
    evalJumpLabels(sts)
    fix {
      fun v([]) = {
        evalStatements(sts)
        $exit@([])
      }
    }
    x <- resolveVar(l)
    #ref-store(x, v)
  }
  evalJumpLabels([_|sts]) = evalJumpLabels(sts)
  evalJumpLabels([]) = hole

  evalStatements([a|b]) = {
    evalStatement(a)
    evalStatements(b)
  }

  evalStatements([JumpLabel(l)|_]) = {
    v <- var(l)
    v@([])
  }
  label noop/0:

  evalStatements([]) = hole

  evalStatement(Print(e)) = {
    x <- evalExpression(e)
    #print(x)
  }

  evalStatement(Simple(e)) = {
    evalExpression(e)
  }

  evalStatement(Assign(Variablee(_, x), e)) = {
    v <- evalExpression(e)
    s <- resolveVar(x)
    #ref-store(s, v)
  }

  evalStatements([Jump(x)|_]) = {
    s <- resolveVar(x)
    lab <- #ref-fetch(s)
    lab@([])
  }
  label noop/0:

  evalStatement(Jump(x)) = {
    s <- resolveVar(x)
    lab <- #ref-fetch(s)
    lab@([])
  }
  label noop/0:

  evalStatement(If(c, st, e)) = {
    true <- fresh-var(true)
    false <- evalElse(e, cont)
    fix {
      fun true([]) = {
        evalStatements(st)
        cont@([])
      }
    }
    evalCondition(c, true, false)
  } label cont/0:

  evalCondition(Zero(e), true, false) = {
    v <- evalExpression(e)
    if #int-eq(v, int('0)) then {
      true@([])
    } else {
      false@([])
    }
  }

  evalElse(Elif(c, st, e), cont) = {
    branch <- fresh-var(elif)
    true <- fresh-var(true)
    false <- evalElse(e, cont)
    fix {
      fun true([]) = {
        evalStatements(st)
        cont@([])
      }
      fun branch([]) = {
        evalCondition(c, true, false)
      }
    }
    branch
  }
  evalElse(Else(st), cont) = {
    branch <- fresh-var(el)
    fix {
      fun branch([]) = {
        evalStatements(st)
        cont@([])
      }
    }
    branch
  }
  evalElse(NoElse(), cont) = cont

  evalStatement(v@VarScope(stmts)) = {
    with $exit = $exit do{
      evalVars(vars(v))
      evalJumpLabels(stmts)
      evalStatements(stmts)
    }
    hole
  }

  evalExpression(Value(Int(i))) = int(i)

  evalExpression(Value(String(x))) = str(x)

  evalExpression(Variable(Variablee(_, x))) = {
    s <- resolveVar(x)
    #ref-fetch(s)
  }

  evalExpression(Add(e1, e2)) = {
    v1 <- evalExpression(e1)
    v2 <- evalExpression(e2)
    #int-add(v1, v2)
  }

  evalExpression(Sub(e1, e2)) = {
    v1 <- evalExpression(e1)
    v2 <- evalExpression(e2)
    #int-sub(v1, v2)
  }

  evalExpression(Mul(e1, e2)) = {
    v1 <- evalExpression(e1)
    v2 <- evalExpression(e2)
    #int-mul(v1, v2)
  }

  evalExpression(Div(e1, e2)) = {
    v1 <- evalExpression(e1)
    v2 <- evalExpression(e2)
    #int-div(v1, v2)
  }

  evalExpression(l@Lambda(paramNames, e)) = {
    lambda <- fresh-var(lambda)
    tail <- fresh-var(tail)
    params <- makeParamVars(paramNames)
    fix {
      fun lambda(params ++ [tail]) = {
        evalVars(vars(l))
        evalParameters(paramNames, params)
        r <- evalExpression(e)
        tail@([r])
      }
    }
    lambda
  }

  makeParamVars([h|t]) = [fresh-var(p)|makeParamVars(t)]
  makeParamVars([]) = []

  evalParameters([name|nl], [param|pl]) = {
    s <- resolveVar(name)
    #ref-store(s, param)
    evalParameters(nl, pl)
  }

  evalParameters([], []) = hole

  evalExpression(Apply(e1, es)) = {
    f <- evalExpression(e1)
    arg <- evalExpressions(es)

    f@(arg ++ [ret])
    label ret/1:
  }

  evalExpressions([e| es]) = {
    v1 <- evalExpression(e)
    vs <- evalExpressions(es)
    [v1|vs]
  }
  evalExpressions([]) = []
  
  resolveVar(x) = {
    s <- unpackScope(scope(x))
    y <- '"_" + s
    var(x + y)
  }
  
  unpackPath([p]) = p
  unpackScope([Scope(_, s)]) = s
  unpackIdList([x]) = x

