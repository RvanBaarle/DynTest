module main

imports
  signatures/start-sig


primitives
  statement #print(@value)
  statement #exit()
  expression #int-add(@value, @value)
  expression #int-sub(@value, @value)
  expression #int-mul(@value, @value)
  expression #int-div(@value, @value)
  expression #record-new()
  expression #record-read(@value, @value)
  expression #record-write(@value, @value, @value)
  conditional #int-eq(@value, @value)

signature
constructors
  String : STRING -> Value

rules
  evalProgram :: 'Start -> Holy

  evalStatements :: @value * List('Statement) -> Holy

  evalStatement :: @value * 'Statement -> Holy

  evalExpression :: @value * 'Expression -> Holy(@value)

  evalExpressions :: @value * List('Expression) -> Holy(List(@value))

  makeParamVars :: List('ID) -> List(@value)

  evalParameters :: @value * List('ID) * List(@value) -> Holy

  evalLabels :: @value * List('Statement) -> Holy

  evalCondition :: @value * 'Condition * @value * @value -> @statement

  evalElse :: @value * 'Else * @value -> Holy(@value)

  evalProgram(Program(l)) = {
    let var('"_exit") = exit in {
      s <- #record-new()
      evalLabels(s, l)
      evalStatements(s, l)
      exit@([])
    }
  }
  label exit/0:

  evalLabels(s, [Label(l)|sts]) = {
    v <- var(l)
    evalLabels(s, sts)
    fix {
      fun v([]) = {
        evalStatements(s, sts)
        var('"_exit")@([])
      }
    }
    #record-write(s, str(l), v)
  }
  evalLabels(s, [_|sts]) = evalLabels(s, sts)
  evalLabels(s, []) = hole

  evalStatements(s, [a|b]) = {
    evalStatement(s, a)
    evalStatements(s, b)
  }

  evalStatements(s, [Label(l)|_]) = {
    v <- var(l)
    v@([])
  }
  label noop/0:

  evalStatements(s, []) = hole

  evalStatement(s, Print(e)) = {
    x <- evalExpression(s, e)
    #print(x)
  }

  evalStatement(s, Simple(e)) = {
    evalExpression(s, e)
  }

  evalStatement(s, Assign(Variablee(x), e)) = {
    v <- evalExpression(s, e)
    #record-write(s, str(x), v)
  }

  evalStatements(s, [Jump(x)|_]) = {
    lab <- #record-read(s, str(x))
    lab@([])
  }
  label noop/0:

  evalStatement(s, Jump(x)) = {
    lab <- #record-read(s, str(x))
    lab@([])
  }
  label noop/0:

  evalStatement(s, If(c, st, e)) = {
    true <- fresh-var(true)
    false <- evalElse(s, e, cont)
    fix {
      fun true([]) = {
        evalStatements(s, st)
        cont@([])
      }
    }
    evalCondition(s, c, true, false)
  } label cont/0:

  evalCondition(s, Zero(e), true, false) = {
    v <- evalExpression(s, e)
    if #int-eq(v, int('0)) then {
      true@([])
    } else {
      false@([])
    }
  }

  evalElse(s, Elif(c, st, e), cont) = {
    branch <- fresh-var(elif)
    true <- fresh-var(true)
    false <- evalElse(s, e, cont)
    fix {
      fun true([]) = {
        evalStatements(s, st)
        cont@([])
      }
      fun branch([]) = {
        evalCondition(s, c, true, false)
      }
    }
    branch
  }
  evalElse(s, Else(st), cont) = {
    branch <- fresh-var(el)
    fix {
      fun branch([]) = {
        evalStatements(s, st)
        cont@([])
      }
    }
    branch
  }
  evalElse(s, NoElse(), cont) = cont

  evalExpression(s, Value(Int(i))) = int(i)

  evalExpression(s, Value(String(x))) = str(x)

  evalExpression(s, Variable(Variablee(x))) = #record-read(s, str(x))

  evalExpression(s, Add(e1, e2)) = {
    v1 <- evalExpression(s, e1)
    v2 <- evalExpression(s, e2)
    #int-add(v1, v2)
  }

  evalExpression(s, Sub(e1, e2)) = {
    v1 <- evalExpression(s, e1)
    v2 <- evalExpression(s, e2)
    #int-sub(v1, v2)
  }

  evalExpression(s, Mul(e1, e2)) = {
    v1 <- evalExpression(s, e1)
    v2 <- evalExpression(s, e2)
    #int-mul(v1, v2)
  }

  evalExpression(s, Div(e1, e2)) = {
    v1 <- evalExpression(s, e1)
    v2 <- evalExpression(s, e2)
    #int-div(v1, v2)
  }

  evalExpression(s, Lambda(paramNames, e)) = {
    lambda <- fresh-var(lambda)
    tail <- fresh-var(tail)
    params <- makeParamVars(paramNames)
    fix {
      fun lambda(params ++ [tail]) = {
        evalParameters(s, paramNames, params)
        r <- evalExpression(s, e)
        tail@([r])
      }
    }
    lambda
  }

  makeParamVars([h|t]) = [fresh-var(p)|makeParamVars(t)]
  makeParamVars([]) = []

  evalParameters(s, [name|nl], [param|pl]) = {
    #record-write(s, str(name), param)
    evalParameters(s, nl, pl)
  }

  evalParameters(s, [], []) = hole

  evalExpression(s, Apply(e1, es)) = {
    f <- evalExpression(s, e1)
    arg <- evalExpressions(s, es)

    f@(arg ++ [ret])
    label ret/1:
  }

  evalExpressions(s, [e| es]) = {
    v1 <- evalExpression(s, e)
    vs <- evalExpressions(s, es)
    [v1|vs]
  }
  evalExpressions(s, []) = []

